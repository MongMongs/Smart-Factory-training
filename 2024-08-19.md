## - 전송 매체
## 

## 근거리 통신망 (LAN)

1) 이더넷 : 한 컴퓨터에서 다른 컴퓨터로 데이터를 옮김 다른 컴퓨터에서 데이터를 같이 보내면 충돌 일어남!

- 데이터 전송률 1~10Mbps

- 고속 이더넷 100Mbps(아직도 10 쓰는곳 많아서 100이면 고속임)

- 프레임 형식

![image](https://github.com/user-attachments/assets/bcaf63f7-f5c8-424f-bbd0-1f469d09d226)

2) 토큰 링

- 권한을 가진 녀석 만 발언권 있음

![image](https://github.com/user-attachments/assets/9c0b5b03-2cc0-49be-8f5c-5d55fc00cbe5)

## 교환(Switching)

1) 회선 교환 망 : 전용선 => 비쌈

- 100% 통신할 수 있다고 가정하기에 3개 이상 필요

![image](https://github.com/user-attachments/assets/1e8f8ce6-581b-4277-bf67-69f1e9a9c9ea)


2) 패킷 교환 망(wifi) : 부족한것을 빈곳에서 체움 => 저렴

- 모두가 바쁠 때(통화량이 많음) 연결되지않음 => 큰 경기가 열릴경우(통화량 많아짐) 중개차로 연결라인 추가 함

![image](https://github.com/user-attachments/assets/7d2eabf6-87d3-4e44-8b23-b28ac4315715)

## 광역 통신망(WAN)

<img width="520" alt="다운로드" src="https://github.com/user-attachments/assets/7fb90f31-14db-49e8-b7f7-418d989a8796">

- 짤은거리, 적은 에너지 무선 연결 => NFC, ZigBEe

- Bluetooth 는 많은 에너지 데이터 사용됨

-  wifi 속도는빠르나 거리가 100미터고 공간 분리 시 연결이 잘 안됨, 중계기 연결해야 더 멀리 데이터 전달 가능

- LoRa 무선 송신 표준 멀리 통신이 가능하나 송슈 데이터 크기가 작음

- 최대 거리에서 절반을 자른 거리까지가 잘 통신된다고 생각하면 된다.

## 연결장치

1) 리피터

- OSI 모델의 물리층 기능을 수행하는 장치

- 리피터는 망의 물리적인 길이를 확장하는데 사용

- 산업용 리피터가 따로 있음

- 통신에서는 보안을 중요시 않게 생각하지만 보안이 중요함!

![image](https://github.com/user-attachments/assets/8702b80a-7881-4498-88f5-4fc30339b649)

![image](https://github.com/user-attachments/assets/c70b1dbf-7632-48a2-8c15-8ee990c25db5)

2) 브리지

- OSI 모델의 물리층과 데이터 링크 층의 기능 수행

- 브리지는 큰 네트워크를 작은 세그먼트로 분할

![image](https://github.com/user-attachments/assets/a56c7892-e6e8-420f-b996-f208a8fc323b)

![image](https://github.com/user-attachments/assets/e583c672-3799-483d-b70c-b9b236053d76)

3) 라우터

- OSI 모델의 물리, 데이터 링크, 네트워크 층의 기능 수행

- 라우터는 다중 상호연결 망에서 패킷을 중계

![image](https://github.com/user-attachments/assets/c4184587-96d5-4f9e-ba16-846e5cbe3346)

![image](https://github.com/user-attachments/assets/8053639c-bf67-48d8-a610-107f9819d46b)

4) 게이트웨이
- OSI 모델의 모든 계층의 기능 수행(프로토콜 변환기)
 
- 두 네트워크 사이의 통신을 위한 출입구
  
![image](https://github.com/user-attachments/assets/bcb0f036-f42b-415d-b042-5ece2511ecd0)

![image](https://github.com/user-attachments/assets/60f9596a-dd91-431b-aedd-b95ae9e87a64)

##  소켓

소켓 통신을 하려면 임베디드, 리눅스가 올라가 있어야함

추상화 된 코드가 어려운 이유는 안보이기 때문 인공지능에서 텐서 플로 아직도 사용하는 이유 원시적인 코드가 응용이 쉬움

아래코드는 c를 설명한것인데 c# 코드를 이해하기 위해 c 코드를 먼저 봄 

1) 소켓의 생성 (socket)

2) 소켓의 주소와 할당(binding))

- 소켓의 주소 정보는 IP와 port로 구성된다.

sockfd  소켓 번호

sockaddr 객체 형성해야함(아래 코드는 c 이기에 억지로 만듬), 주소 만듦

int bind(int sockfd, struct sockaddr"")

3) 연결 요청이 가능한 상태의 소켓(listen)

4) 연결 요청의 수락(accept)

우리가 사용할 장비는 펌웨어 장치임 점대점 통신을 해야함 운영체제(os)가 있어야 소켓을 올릴 수 있음

임베디드 리눅스는 거의 모든 장치에서 사용가능, 리눅스를 사용하면 메모리 프로세스를 파일로 만들어 처리 가능(물론 안드로이드, BOS 등 다른 프로그램 올릴 수 있음)

아두이노는 펌웨어 라즈베리파이 정도 되야 소켓 라이브러리 사용 가능

아두이노는 다른 장비를 같이 사용해야 os 올릴 수 있음

리눅스가 

c, ㅊ+로 코ㅡㄷ를 짜면 라이브러리도 깔아야 하고(윈샵 소켓2등) 소켓마다 따로 코딩을 해줘야함, 함수, 내용도 달라 짐 그렇기에 c#/java 사용하는것을 추천, 공부도 c 랑 윈샵 소켓 등의 프로그램 2개를 공부해야함

## 프로토콜

: 개념적으로 약속의 의미 

- 주로 인터넷 프로토콜 사용 하지만 도메인 여러개(pf_inet, pf_inet6 등 총 5개, 우리는 사용함 pf_inet) 있음

## 인터넷 주소

c 나 c+=은 인터넷 주소 만들어야함

port 번호는 4 바이트 65535 이하까지만 사용 가능

구조체 :  ip랑 port번호 따로 만들어야함/ c#은 가공 가능! 훨씬 쉬움 그래도 c, c++은 자세하게 설정 가능!
sockaddr_in 

c#은 포인터가 없고 주소체게 단순하게 추상화해놓음/ 소켓방식, tcpㅐic둘다 배울 예정

## 바이트 올더

intel cpu는 리클 엔디안임, 큰수가먼저옴 (컴퓨터는 리틀 엔디안!)

울트라 스팍 등의 cpu는 빅 엔디안임 작은 번지수부터 옴, 네트워크 장치(서버용 장치)는 보통 빅 엔디안 임

=> 이걸 빅/리틀 엔디안 중 하나로 바꿔 주는게 필요함, c/ c++로 작성할때는 이것이 중요함

c 에서는 주소를 만들 때 항상 변환해야함! 공간을 만들고 할당하는 것등 자잘한것 까지 코드 짜야함! c#은 아님!

## TCP기반 서버=





