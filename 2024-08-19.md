## - 전송 매체
## 

## 근거리 통신망 (LAN)

1) 이더넷 : 한 컴퓨터에서 다른 컴퓨터로 데이터를 옮김 다른 컴퓨터에서 데이터를 같이 보내면 충돌 일어남!

- 데이터 전송률 1~10Mbps

- 고속 이더넷 100Mbps(아직도 10 쓰는곳 많아서 100이면 고속임)

- 프레임 형식

![image](https://github.com/user-attachments/assets/bcaf63f7-f5c8-424f-bbd0-1f469d09d226)

2) 토큰 링

- 권한을 가진 녀석 만 발언권 있음

![image](https://github.com/user-attachments/assets/9c0b5b03-2cc0-49be-8f5c-5d55fc00cbe5)

## 교환(Switching)

1) 회선 교환 망 : 전용선 => 비쌈

- 100% 통신할 수 있다고 가정하기에 3개 이상 필요

![image](https://github.com/user-attachments/assets/1e8f8ce6-581b-4277-bf67-69f1e9a9c9ea)


2) 패킷 교환 망(wifi) : 부족한것을 빈곳에서 체움 => 저렴

- 모두가 바쁠 때(통화량이 많음) 연결되지않음 => 큰 경기가 열릴경우(통화량 많아짐) 중개차로 연결라인 추가 함

![image](https://github.com/user-attachments/assets/7d2eabf6-87d3-4e44-8b23-b28ac4315715)

## 광역 통신망(WAN)

<img width="520" alt="다운로드" src="https://github.com/user-attachments/assets/7fb90f31-14db-49e8-b7f7-418d989a8796">

- 짤은거리, 적은 에너지 무선 연결 => NFC, ZigBEe

- Bluetooth 는 많은 에너지 데이터 사용됨

-  wifi 속도는빠르나 거리가 100미터고 공간 분리 시 연결이 잘 안됨, 중계기 연결해야 더 멀리 데이터 전달 가능

- LoRa 무선 송신 표준 멀리 통신이 가능하나 송슈 데이터 크기가 작음

- 최대 거리에서 절반을 자른 거리까지가 잘 통신된다고 생각하면 된다.

## 연결장치

1) 리피터

- OSI 모델의 물리층 기능을 수행하는 장치

- 리피터는 망의 물리적인 길이를 확장하는데 사용

- 산업용 리피터가 따로 있음

- 통신에서는 보안을 중요시 않게 생각하지만 보안이 중요함!

![image](https://github.com/user-attachments/assets/8702b80a-7881-4498-88f5-4fc30339b649)

![image](https://github.com/user-attachments/assets/c70b1dbf-7632-48a2-8c15-8ee990c25db5)

2) 브리지

- OSI 모델의 물리층과 데이터 링크 층의 기능 수행

- 브리지는 큰 네트워크를 작은 세그먼트로 분할

![image](https://github.com/user-attachments/assets/a56c7892-e6e8-420f-b996-f208a8fc323b)

![image](https://github.com/user-attachments/assets/e583c672-3799-483d-b70c-b9b236053d76)

3) 라우터

- OSI 모델의 물리, 데이터 링크, 네트워크 층의 기능 수행

- 라우터는 다중 상호연결 망에서 패킷을 중계

![image](https://github.com/user-attachments/assets/c4184587-96d5-4f9e-ba16-846e5cbe3346)

![image](https://github.com/user-attachments/assets/8053639c-bf67-48d8-a610-107f9819d46b)

4) 게이트웨이
- OSI 모델의 모든 계층의 기능 수행(프로토콜 변환기)
 
- 두 네트워크 사이의 통신을 위한 출입구
  
![image](https://github.com/user-attachments/assets/bcb0f036-f42b-415d-b042-5ece2511ecd0)

![image](https://github.com/user-attachments/assets/60f9596a-dd91-431b-aedd-b95ae9e87a64)

##  소켓

소켓 통신을 하려면 임베디드, 리눅스가 올라가 있어야함

추상화 된 코드가 어려운 이유는 안보이기 때문 인공지능에서 텐서 플로 아직도 사용하는 이유 원시적인 코드가 응용이 쉬움

아래코드는 c를 설명한것인데 c# 코드를 이해하기 위해 c 코드를 먼저 봄 

1) 소켓의 생성 (socket)

2) 소켓의 주소와 할당(binding))

- 소켓의 주소 정보는 IP와 port로 구성된다.

sockfd  소켓 번호

sockaddr 객체 형성해야함(아래 코드는 c 이기에 억지로 만듬), 주소 만듦

int bind(int sockfd, struct sockaddr"")

3) 연결 요청이 가능한 상태의 소켓(listen)

4) 연결 요청의 수락(accept)

우리가 사용할 장비는 펌웨어 장치임 점대점 통신을 해야함 운영체제(os)가 있어야 소켓을 올릴 수 있음

임베디드 리눅스는 거의 모든 장치에서 사용가능, 리눅스를 사용하면 메모리 프로세스를 파일로 만들어 처리 가능(물론 안드로이드, BOS 등 다른 프로그램 올릴 수 있음)

아두이노는 펌웨어 라즈베리파이 정도 되야 소켓 라이브러리 사용 가능

아두이노는 다른 장비를 같이 사용해야 os 올릴 수 있음

리눅스가 

c, ㅊ+로 코ㅡㄷ를 짜면 라이브러리도 깔아야 하고(윈샵 소켓2등) 소켓마다 따로 코딩을 해줘야함, 함수, 내용도 달라 짐 그렇기에 c#/java 사용하는것을 추천, 공부도 c 랑 윈샵 소켓 등의 프로그램 2개를 공부해야함

## 프로토콜

: 개념적으로 약속의 의미 

- 주로 인터넷 프로토콜 사용 하지만 도메인 여러개(pf_inet, pf_inet6 등 총 5개, 우리는 사용함 pf_inet) 있음

## 인터넷 주소

c 나 c+=은 인터넷 주소 만들어야함

port 번호는 4 바이트 65535 이하까지만 사용 가능

구조체 :  ip랑 port번호 따로 만들어야함/ c#은 가공 가능! 훨씬 쉬움 그래도 c, c++은 자세하게 설정 가능!
sockaddr_in 

c#은 포인터가 없고 주소체게 단순하게 추상화해놓음/ 소켓방식, tcpㅐic둘다 배울 예정

## 바이트 올더

intel cpu는 리클 엔디안임, 큰수가먼저옴 (컴퓨터는 리틀 엔디안!)

울트라 스팍 등의 cpu는 빅 엔디안임 작은 번지수부터 옴, 네트워크 장치(서버용 장치)는 보통 빅 엔디안 임

=> 이걸 빅/리틀 엔디안 중 하나로 바꿔 주는게 필요함, c/ c++로 작성할때는 이것이 중요함

c 에서는 주소를 만들 때 항상 변환해야함! 공간을 만들고 할당하는 것등 자잘한것 까지 코드 짜야함! c#은 아님!

## TCP기반 서버=

## - 임베디드 프로그래밍에서  직렬화, 역 직렬화
개념 중요

```
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApp120
{
    internal class Program
    {
        static void Main(string[] args)
        {
            byte[] boolBytes = BitConverter.GetBytes(true);
            byte[] shortBytes = BitConverter.GetBytes((short)32000);
            byte[] intBytes = BitConverter.GetBytes(1652300);

            bool boolResult = BitConverter.ToBoolean(boolBytes, 0);
            short shortResult = BitConverter.ToInt16(shortBytes, 0);
            int intResult = BitConverter.ToInt32(intBytes, 0);

            Console.WriteLine(BitConverter.ToString(boolBytes));
            Console.WriteLine(BitConverter.ToString(shortBytes));
            Console.WriteLine(BitConverter.ToString(intBytes));

            Console.WriteLine(boolResult);
            Console.WriteLine(shortResult);
            Console.WriteLine(intResult);

        }
    }
}
```

## - 실행 결과

```
01
00-7D
4C-36-19-00
True
32000
1652300
```

## - 메모리 스트림 테스트
메모리에 작성 후 다시 읽어오기

```
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoryStreamTest
{
    internal class Program
    {
        static void Main(string[] args)
        {
            byte[] shortBytes = BitConverter.GetBytes((short)32000);// short = 2byte
            byte[] intBytes = BitConverter.GetBytes(1652300);// 4byte = 아무것도 안적혔기 때문

            MemoryStream ms = new MemoryStream(); // 메모리 스트림 두 데이터가 붙어 나감,
            ms.Write(shortBytes, 0, shortBytes.Length);
            ms.Write(intBytes, 0, intBytes.Length);

            ms.Position = 0; // 파일을 읽는 시작점을 0으로 함
            // 리눅스에서 임베디드 코딩을 할 때 메모리를 사용하지만 메모리를 파일로 처리함
            // 메모리 속도가 ddr5가 56000MHZ -> 빠름, 그래서 다운로드 할 때 메모리로 가져와서 그걸 ssd등 기억장치에 작성하는 형식 많이 사용함, 빨라서!
            // ssd는 순차쓰기 읽기가 : 4000MB/s
            // 하드디스크는 300MB/s 정도로 느림
            // 속도=> cpu>메모리>메모리>ssd>hdd>프린트(IO)

            //MemoryStream으로부터 short를 역직렬화
            byte[] outBytes = new byte[2];
            ms.Read(outBytes, 0, 2);//읽어옴
            // 크기를 모르면 안됨 크기가 잘못되면 깨져보임
            // 프로토콜 =  크기 규약 포함되어있음
            int shortResult = BitConverter.ToInt16(outBytes, 0);//역 직렬화
            Console.WriteLine(shortResult);

            //Int 역직렬화
            outBytes = new byte[4];
            ms.Read(outBytes, 0, 4);// 읽어지면 앞부분 날라감 앞에서 2byte 읽었기 때문에 0 부터 읽어옴
            int intResult = BitConverter.ToInt32(outBytes, 0);
            Console.WriteLine(intResult);

        }
    }
}
```

## - 실행 결과

```
32000
1652300
```

## - Quiz 메모장에 작성된 글 메모리로 읽어 콘솔에 출력 
UTF8Encording 으로 하면 한글 깨짐 -> 언어 포멧이 안맞아서 그런 경우 많음, 한글은 유니코드에서 3바이트임, 영어는 2 바이트, 영문은 안깨짐
메모리로 가져와 처리하는게 그냥 불러오는것보다 훨 빠름
서버랙에 보드나 피씨를 넣음

```
using System.Text;

namespace ConsoleApp121
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string path = @"C:\Temp\abc.txt";
            StreamReader sr = new StreamReader(path, Encoding.UTF8);//바이트로 된 데이터 읽어오기에 가장 좋음!
            //string txt =  sr.readtoend(); // 바로 읽어오는방법
            //console.writeline(txt);
            string txt = sr.ReadToEnd();

            MemoryStream ms = new MemoryStream();
            byte[] strBytes = Encoding.UTF8.GetBytes(txt);//문자열 직렬화  => byte 배열로 만들었다
            ms.Write(strBytes, 0, strBytes.Length);
            ms.Position = 0;

            StreamReader sr2 = new StreamReader(ms,Encoding.UTF8, true);
            txt = sr2.ReadToEnd();
            Console.WriteLine(txt);


        }
    }
}

```

## - 실행 결과

```
Hello World
```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```
## - 

```

```

## - 실행 결과

```

```




