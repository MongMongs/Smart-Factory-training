# - OpenCV


## - filter 


### - HueThresholdWinForm


- 폼 구성

![image](https://github.com/user-attachments/assets/06371695-c6e9-4d4f-8dff-5156f2fcf6ab)


```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;

namespace WinFormsApp44
{
    public partial class Form1 : Form
    {
        private int hueMin = 0;
        private int hueMax = 255;


        private Mat originalImage;
        public Form1()
        {
            InitializeComponent();

            // 트랙바 초기화 및 이벤트 연결
            tbHue01.Maximum = 255;
            tbHue02.Maximum = 255;

            tbHue01.Scroll += TbHue01_Scroll;
            tbHue02.Scroll += TbHue02_Scroll;

            // 예시 이미지 로드
            LoadOriginalImage();
        }

        private void LoadOriginalImage()
        {
            originalImage = Cv2.ImRead("C:\\Temp\\cv_imgs\\newjeans.jpg");  // 원본 이미지 파일 경로
            picOrigin.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(originalImage);
        }

        private void TbHue01_Scroll(object sender, EventArgs e)
        {
            hueMin = tbHue01.Value;
            textHue01.Text = $"Hue_th1 : {hueMin}";
            ApplyHueFilter();  // 필터 적용
        }

        private void TbHue02_Scroll(object sender, EventArgs e)
        {
            hueMax = tbHue02.Value;
            textHue02.Text = $"Hue_th2 : {hueMax}";
            ApplyHueFilter();  // 필터 적용
        }
        private void ApplyHueFilter()
        {
            if (originalImage == null) return;

            // 이미지를 HSV 색상으로 변환
            Mat hsvImage = new Mat();
            Cv2.CvtColor(originalImage, hsvImage, ColorConversionCodes.BGR2HSV);

            // Hue 범위에 따라 필터링
            Mat mask = new Mat();
            Cv2.InRange(hsvImage, new Scalar(hueMin, 50, 50), new Scalar(hueMax, 255, 255), mask);

            // 결과를 picHue에 표시
            picHue.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(mask);
        }

        private void tbHue01_Scroll_1(object sender, EventArgs e)
        {

        }
    }
}
```


### - 실행 결과


- 시작 화면

![image](https://github.com/user-attachments/assets/2298136b-b7a1-4d2e-9b7b-ab05877fef6c)


- 트랙바 1(tbHue01) 만 드래그


![image](https://github.com/user-attachments/assets/8808e33f-6ce5-43f9-b821-bd4cbe6a7b92)
![image](https://github.com/user-attachments/assets/389254fd-bfe4-4716-ac25-fe4278a1a5c1)


- 트랙바 2(tbHue02) 드래그


![image](https://github.com/user-attachments/assets/71e39ea2-646e-4fab-831a-743e6d5df7e5)
![image](https://github.com/user-attachments/assets/21e32799-ce6b-4b35-9522-9869c0d47170)


### - 이미지 블러 처리


```
using OpenCvSharp;
using System;

namespace _20241024_Blurring01
{
    internal class Program
    {
        static void Filter(Mat img, out Mat dst, Mat mask)
        {
            dst = new Mat(img.Size(), MatType.CV_32F, Scalar.All(0));
            Point h_m = new Point(mask.Width / 2, mask.Height / 2);

            for (int i = h_m.Y; i < img.Rows - h_m.Y; i++)
            {
                for (int k = h_m.X; k < img.Cols - h_m.X; k++)
                {
                    float sum = 0;
                    for (int u = 0; u < mask.Rows; u++)
                    {
                        for (int v = 0; v < mask.Cols; v++)
                        {
                            int y = i + u - h_m.Y;
                            int x = k + v - h_m.X;
                            sum += mask.At<float>(u, v) * img.At<Vec3b>(y, x)[0];  // 그레이스케일 단순화
                        }
                    }
                    dst.Set<float>(i, k, sum);
                }
            }
        }

        static void Main(string[] args)
        {
            Mat image = Cv2.ImRead("C:\\Temp\\cv_imgs\\filter_blur.jpg", ImreadModes.Grayscale);
            if (image.Empty())
            {
                Console.WriteLine("이미지를 로드할 수 없습니다.");
                return;
            }

            float[] data1 =
            {
                1/9f, 1/9f, 1/9f,
                1/9f, 1/9f, 1/9f,
                1/9f, 1/9f, 1/9f
            };
            float[] data2 =
            {
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f
            };

            //Mat mask = new Mat(3, 3, MatType.CV_32F, data1); //Error
            Mat mask = new Mat(5, 5, MatType.CV_32F);

            for (int i = 0; i < mask.Rows; i++)
            {
                for (int k = 0; k < mask.Cols; k++)
                {
                    mask.Set<float>(i, k, data2[i * mask.Cols + k]);
                }
            }

            Filter(image, out Mat blur, mask);

            blur.ConvertTo(blur, MatType.CV_8U);

            Cv2.ImShow("image", image);
            Cv2.ImShow("blur", blur);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 이미지


![image](https://github.com/user-attachments/assets/066dcf05-2b57-48a1-9f9b-3d65f2ac6759)


- 블러 처리된 이미지


![image](https://github.com/user-attachments/assets/4707acf0-8a7a-481f-b1e8-ba26bf2243dd)



### - 가우시안 블러(Gaussian Blur)


```
using OpenCvSharp;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BluringDirect
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\filter_blur.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("이미지 문제발생");

            Mat blur = new Mat();

            // OpenCV 함수인 GaussianBlur를 사용하여 블러링 처리
            Cv2.GaussianBlur(src, blur, new OpenCvSharp.Size(5, 5), 0); //Size 함수의 3을 5로 바꾸면 5 * 5 필터가 되고 1/25f가 입력됨

            Cv2.ImShow("src", src);
            Cv2.ImShow("blur", blur);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 이미지


![image](https://github.com/user-attachments/assets/7f71f4fb-0111-491f-baf6-2b25d390fa39)


- 가우시안 블러 처리된 이미지


![image](https://github.com/user-attachments/assets/065429d1-8260-47fa-8b50-1a6d35205d6f)



### - 샤프닝(Sharpening)


샤프닝이란?

블러링이 이웃 화소의 차이를 감소시켜서 부드럽게 만드는 것이라면, 샤프닝은 반대로 입력 화소에서 이웃 화소끼리 차이를 크게 되도록 출력 화소를 만들어서 날카로운 느낌이 나게 만드는 것이다.

이는 OpenCV 내장 함수 대신, 각 픽셀에 대해 커널을 직접 적용하여 새로운 값을 계산하는 방식이다.

(참고 자료 : https://atonlee.t7 istory.com/11)

```
using OpenCvSharp;

namespace _20241024_Sharpening01
{
    internal class Program
    {
        // 회선함수 (Filter) 동일
        // 이미지의 각 픽셀에 대해 마스크를 적용해 그 값을 새로 계산합니다.
        // 이미지를 순차적으로 순회하면서 커널을 각 픽셀에 적용하는 방식으로, **중심점(h_m)**을 기준으로 마스크가 이미지 전체에 걸쳐 적용됩니다.
        // 픽셀 단위로 값을 읽어와 커널 값과 곱해 더한 후, 결과를 출력 이미지에 설정하는 방식입니다.
        static void Filter(Mat img, out Mat dst, Mat mask)
        {
            dst = new Mat(img.Size(), MatType.CV_32F, Scalar.All(0));
            Point h_m = new Point(mask.Width / 2, mask.Height / 2);

            for (int i = h_m.Y; i < img.Rows - h_m.Y; i++)
            {
                for (int k = h_m.X; k < img.Cols - h_m.X; k++)
                {
                    float sum = 0;
                    for (int u = 0; u < mask.Rows; u++)
                    {
                        for (int v = 0; v < mask.Cols; v++)
                        {
                            int y = i + u - h_m.Y;
                            int x = k + v - h_m.X;
                            sum += mask.At<float>(u, v) * img.At<byte>(y, x);
                        }
                    }
                    dst.Set<float>(i, k, sum);
                }
            }
        }

        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\filter_sharpen.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("Failed to load image");

            float[] data1 =
            {
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            };

            float[] data2 =
            {
                -1, -1, -1,
                -1, 9, -1,
                -1, -1, -1
            };

            Mat mask1 = new Mat(3, 3, MatType.CV_32F);
            Mat mask2 = new Mat(3, 3, MatType.CV_32F);

            // data1 값을 mask1에 설정
            for (int i = 0; i < mask1.Rows; i++)
            {
                for (int j = 0; j < mask1.Cols; j++)
                {
                    mask1.Set<float>(i, j, data1[i * mask1.Cols + j]);
                }
            }

            // data2 값을 mask2에 설정
            for (int i = 0; i < mask2.Rows; i++)
            {
                for (int j = 0; j < mask2.Cols; j++)
                {
                    mask2.Set<float>(i, j, data2[i * mask2.Cols + j]);
                }
            }

            Filter(src, out Mat sharpen1, mask1);
            Filter(src, out Mat sharpen2, mask2);

            sharpen1.ConvertTo(sharpen1, MatType.CV_8U);
            sharpen2.ConvertTo(sharpen2, MatType.CV_8U);

            Cv2.ImShow("sharpen1", sharpen1);
            Cv2.ImShow("sharpen2", sharpen2);
            Cv2.ImShow("src", src);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 사진

![image](https://github.com/user-attachments/assets/64a6351d-a50b-49af-a13e-6e0e72744da1)


- sharpen1


![image](https://github.com/user-attachments/assets/a1d25acc-1a37-47ed-aa52-44a0a14f87ff)


- sharpen2


![image](https://github.com/user-attachments/assets/517e48ce-1b6e-445a-bc2a-0e022a53b925)



### - Filter2D 함수 사용해 샤프닝


OpenCV의 내장 함수인 Cv2.Filter2D()를 사용해 회선 연산을 수행

OpenCV의 Filter2D는 최적화가 되어 있어 직접 코드를 입력하는 것 보다 빠르게 실행된다.


```
using OpenCvSharp;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ShapeningDirect
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\filter_sharpen.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("Failed to load image");

            float[] data1 =
            {
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            };

            float[] data2 =
            {
                -1, -1, -1,
                -1, 9, -1,
                -1, -1, -1
            };

            // 마스크(필터) 설정
            // 3x3 크기의 샤프닝 필터를 정의하고, 각 마스크에 샤프닝 커널 값을 설정합니다.
            // data1과 data2는 각각 약한 샤프닝과 강한 샤프닝을 수행합니다.
            Mat mask1 = new Mat(3, 3, MatType.CV_32F);
            Mat mask2 = new Mat(3, 3, MatType.CV_32F);

            // data1 값을 mask1에 설정
            for (int i = 0; i < mask1.Rows; i++)
            {
                for (int j = 0; j < mask1.Cols; j++)
                {
                    mask1.Set<float>(i, j, data1[i * mask1.Cols + j]);
                }
            }

            // data2 값을 mask2에 설정
            for (int i = 0; i < mask2.Rows; i++)
            {
                for (int j = 0; j < mask2.Cols; j++)
                {
                    mask2.Set<float>(i, j, data2[i * mask2.Cols + j]);
                }
            }

            Mat sharpen1 = new Mat();
            Mat sharpen2 = new Mat();

            Cv2.Filter2D(src, sharpen1, MatType.CV_32F, mask1);
            Cv2.Filter2D(src, sharpen2, MatType.CV_32F, mask2);

            // 결과를 CV_8U로 변환
            sharpen1.ConvertTo(sharpen1, MatType.CV_8U);
            sharpen2.ConvertTo(sharpen2, MatType.CV_8U);

            Cv2.ImShow("sharpen1", sharpen1);
            Cv2.ImShow("sharpen2", sharpen2);
            Cv2.ImShow("src", src);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 사진

![image](https://github.com/user-attachments/assets/c6e61f94-a372-457d-b984-532d6883147f)


- sharpen1


![image](https://github.com/user-attachments/assets/50e674ae-660a-4376-9890-b2f449eeb329)


- sharpen2


![image](https://github.com/user-attachments/assets/14fa31f5-a321-468f-9ea5-1b034211b6ae)



### - Roberts edge detection


Roberts Edge 검출이란?

: 이미지에서 경계를 감지하기 위한 방법 중 하나입니다. 차이 연산을 기반으로 하는 간단한 기법으로, 교차하는 두 방향(대각선)의 픽셀 차이를 구해 에지를 검출합니다.


이 코드는 주어진 이미지를 그레이스케일로 읽고, 3x3 크기의 차이 연산을 통해 에지 정보를 추출한 후, 결과를 출력합니다.


```
using System;
using OpenCvSharp;

namespace _20241024_RobertsMask
{
    internal class Program
    {
        // DifferOp 함수: 에지 검출 연산
        static void DifferOp(Mat img, out Mat dst, int maskSize)
        {
            dst = new Mat(img.Size(), MatType.CV_8U, Scalar.All(0));
            Point h_m = new Point(maskSize / 2, maskSize / 2);

            for (int i = h_m.Y; i < img.Rows - h_m.Y; i++)
            {
                for (int j = h_m.X; j < img.Cols - h_m.X; j++)
                {
                    List<byte> mask = new List<byte>();

                    for (int u = 0; u < maskSize; u++)
                    {
                        for (int v = 0; v < maskSize; v++)
                        {
                            int y = i + u - h_m.Y;
                            int x = j + v - h_m.X;
                            mask.Add(img.At<byte>(y, x));
                        }
                    }

                    byte max = 0;
                    for (int k = 0; k < mask.Count / 2; k++)
                    {
                        int start = mask[k];
                        int end = mask[mask.Count - k - 1];

                        byte difference = (byte)Math.Abs(start - end);
                        if (difference > max) max = difference;
                    }

                    dst.Set<byte>(i, j, max);
                }
            }
        }

        // 메인 함수: 이미지 로드 및 필터 적용
        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\edge_test.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("Failed to load image");

            Mat edge;
            DifferOp(src, out edge, 3);

            // 결과 출력
            Cv2.ImShow("src", src);
            Cv2.ImShow("edge", edge);

            Cv2.WaitKey(); Cv2.DestroyAllWindows();
        }
    }
}
```


### - 실행 결과


- 원본 이미지


![image](https://github.com/user-attachments/assets/28372785-5466-42fa-bd6c-de996563db15)


- edge detection 이미지


![image](https://github.com/user-attachments/assets/af54106f-75b0-48be-86c0-173beb38f790)


### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

