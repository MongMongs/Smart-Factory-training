![image](https://github.com/user-attachments/assets/0e01cfcd-3542-407c-a85b-79fbfa70234e)# - OpenCV


## - filter


### - HueThresholdWinForm


- 폼 구성

![image](https://github.com/user-attachments/assets/06371695-c6e9-4d4f-8dff-5156f2fcf6ab)


```
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;

namespace WinFormsApp44
{
    public partial class Form1 : Form
    {
        private int hueMin = 0;
        private int hueMax = 255;


        private Mat originalImage;
        public Form1()
        {
            InitializeComponent();

            // 트랙바 초기화 및 이벤트 연결
            tbHue01.Maximum = 255;
            tbHue02.Maximum = 255;

            tbHue01.Scroll += TbHue01_Scroll;
            tbHue02.Scroll += TbHue02_Scroll;

            // 예시 이미지 로드
            LoadOriginalImage();
        }

        private void LoadOriginalImage()
        {
            originalImage = Cv2.ImRead("C:\\Temp\\cv_imgs\\newjeans.jpg");  // 원본 이미지 파일 경로
            picOrigin.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(originalImage);
        }

        private void TbHue01_Scroll(object sender, EventArgs e)
        {
            hueMin = tbHue01.Value;
            textHue01.Text = $"Hue_th1 : {hueMin}";
            ApplyHueFilter();  // 필터 적용
        }

        private void TbHue02_Scroll(object sender, EventArgs e)
        {
            hueMax = tbHue02.Value;
            textHue02.Text = $"Hue_th2 : {hueMax}";
            ApplyHueFilter();  // 필터 적용
        }
        private void ApplyHueFilter()
        {
            if (originalImage == null) return;

            // 이미지를 HSV 색상으로 변환
            Mat hsvImage = new Mat();
            Cv2.CvtColor(originalImage, hsvImage, ColorConversionCodes.BGR2HSV);

            // Hue 범위에 따라 필터링
            Mat mask = new Mat();
            Cv2.InRange(hsvImage, new Scalar(hueMin, 50, 50), new Scalar(hueMax, 255, 255), mask);

            // 결과를 picHue에 표시
            picHue.Image = OpenCvSharp.Extensions.BitmapConverter.ToBitmap(mask);
        }

        private void tbHue01_Scroll_1(object sender, EventArgs e)
        {

        }
    }
}
```


### - 실행 결과


- 시작 화면

![image](https://github.com/user-attachments/assets/2298136b-b7a1-4d2e-9b7b-ab05877fef6c)


- 트랙바 1(tbHue01) 만 드래그


![image](https://github.com/user-attachments/assets/8808e33f-6ce5-43f9-b821-bd4cbe6a7b92)
![image](https://github.com/user-attachments/assets/389254fd-bfe4-4716-ac25-fe4278a1a5c1)


- 트랙바 2(tbHue02) 드래그


![image](https://github.com/user-attachments/assets/71e39ea2-646e-4fab-831a-743e6d5df7e5)
![image](https://github.com/user-attachments/assets/21e32799-ce6b-4b35-9522-9869c0d47170)


### - 이미지 블러 처리


```
using OpenCvSharp;
using System;

namespace _20241024_Blurring01
{
    internal class Program
    {
        static void Filter(Mat img, out Mat dst, Mat mask)
        {
            dst = new Mat(img.Size(), MatType.CV_32F, Scalar.All(0));
            Point h_m = new Point(mask.Width / 2, mask.Height / 2);

            for (int i = h_m.Y; i < img.Rows - h_m.Y; i++)
            {
                for (int k = h_m.X; k < img.Cols - h_m.X; k++)
                {
                    float sum = 0;
                    for (int u = 0; u < mask.Rows; u++)
                    {
                        for (int v = 0; v < mask.Cols; v++)
                        {
                            int y = i + u - h_m.Y;
                            int x = k + v - h_m.X;
                            sum += mask.At<float>(u, v) * img.At<Vec3b>(y, x)[0];  // 그레이스케일 단순화
                        }
                    }
                    dst.Set<float>(i, k, sum);
                }
            }
        }

        static void Main(string[] args)
        {
            Mat image = Cv2.ImRead("C:\\Temp\\cv_imgs\\filter_blur.jpg", ImreadModes.Grayscale);
            if (image.Empty())
            {
                Console.WriteLine("이미지를 로드할 수 없습니다.");
                return;
            }

            float[] data1 =
            {
                1/9f, 1/9f, 1/9f,
                1/9f, 1/9f, 1/9f,
                1/9f, 1/9f, 1/9f
            };
            float[] data2 =
            {
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f,
                1/25f, 1/25f, 1/25f, 1/25f, 1/25f
            };

            //Mat mask = new Mat(3, 3, MatType.CV_32F, data1); //Error
            Mat mask = new Mat(5, 5, MatType.CV_32F);

            for (int i = 0; i < mask.Rows; i++)
            {
                for (int k = 0; k < mask.Cols; k++)
                {
                    mask.Set<float>(i, k, data2[i * mask.Cols + k]);
                }
            }

            Filter(image, out Mat blur, mask);

            blur.ConvertTo(blur, MatType.CV_8U);

            Cv2.ImShow("image", image);
            Cv2.ImShow("blur", blur);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 이미지


![image](https://github.com/user-attachments/assets/066dcf05-2b57-48a1-9f9b-3d65f2ac6759)


- 블러 처리된 이미지


![image](https://github.com/user-attachments/assets/4707acf0-8a7a-481f-b1e8-ba26bf2243dd)



### - 가우시안 블러(Gaussian Blur)


```
using OpenCvSharp;
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BluringDirect
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\filter_blur.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("이미지 문제발생");

            Mat blur = new Mat();

            // OpenCV 함수인 GaussianBlur를 사용하여 블러링 처리
            Cv2.GaussianBlur(src, blur, new OpenCvSharp.Size(5, 5), 0); //Size 함수의 3을 5로 바꾸면 5 * 5 필터가 되고 1/25f가 입력됨

            Cv2.ImShow("src", src);
            Cv2.ImShow("blur", blur);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 이미지


![image](https://github.com/user-attachments/assets/7f71f4fb-0111-491f-baf6-2b25d390fa39)


- 가우시안 블러 처리된 이미지


![image](https://github.com/user-attachments/assets/065429d1-8260-47fa-8b50-1a6d35205d6f)



### - 샤프닝(Sharpening)


샤프닝이란?

블러링이 이웃 화소의 차이를 감소시켜서 부드럽게 만드는 것이라면, 샤프닝은 반대로 입력 화소에서 이웃 화소끼리 차이를 크게 되도록 출력 화소를 만들어서 날카로운 느낌이 나게 만드는 것이다.

(참고 자료 : https://atonlee.t7 istory.com/11)

```
using OpenCvSharp;

namespace _20241024_Sharpening01
{
    internal class Program
    {
        // 회선함수 (Filter) 동일
        static void Filter(Mat img, out Mat dst, Mat mask)
        {
            dst = new Mat(img.Size(), MatType.CV_32F, Scalar.All(0));
            Point h_m = new Point(mask.Width / 2, mask.Height / 2);

            for (int i = h_m.Y; i < img.Rows - h_m.Y; i++)
            {
                for (int k = h_m.X; k < img.Cols - h_m.X; k++)
                {
                    float sum = 0;
                    for (int u = 0; u < mask.Rows; u++)
                    {
                        for (int v = 0; v < mask.Cols; v++)
                        {
                            int y = i + u - h_m.Y;
                            int x = k + v - h_m.X;
                            sum += mask.At<float>(u, v) * img.At<byte>(y, x);
                        }
                    }
                    dst.Set<float>(i, k, sum);
                }
            }
        }

        static void Main(string[] args)
        {
            string path = @"C:\\Temp\\cv_imgs\\filter_sharpen.jpg";
            Mat src = Cv2.ImRead(path, ImreadModes.Grayscale);

            if (src.Empty())
                throw new Exception("Failed to load image");

            float[] data1 =
            {
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            };

            float[] data2 =
            {
                -1, -1, -1,
                -1, 9, -1,
                -1, -1, -1
            };

            Mat mask1 = new Mat(3, 3, MatType.CV_32F);
            Mat mask2 = new Mat(3, 3, MatType.CV_32F);

            // data1 값을 mask1에 설정
            for (int i = 0; i < mask1.Rows; i++)
            {
                for (int j = 0; j < mask1.Cols; j++)
                {
                    mask1.Set<float>(i, j, data1[i * mask1.Cols + j]);
                }
            }

            // data2 값을 mask2에 설정
            for (int i = 0; i < mask2.Rows; i++)
            {
                for (int j = 0; j < mask2.Cols; j++)
                {
                    mask2.Set<float>(i, j, data2[i * mask2.Cols + j]);
                }
            }

            Filter(src, out Mat sharpen1, mask1);
            Filter(src, out Mat sharpen2, mask2);

            sharpen1.ConvertTo(sharpen1, MatType.CV_8U);
            sharpen2.ConvertTo(sharpen2, MatType.CV_8U);

            Cv2.ImShow("sharpen1", sharpen1);
            Cv2.ImShow("sharpen2", sharpen2);
            Cv2.ImShow("src", src);

            Cv2.WaitKey();
        }
    }
}
```


### - 실행 결과


- 원본 사진

![image](https://github.com/user-attachments/assets/64a6351d-a50b-49af-a13e-6e0e72744da1)


- sharpen1


![image](https://github.com/user-attachments/assets/a1d25acc-1a37-47ed-aa52-44a0a14f87ff)


- sharpen2


![image](https://github.com/user-attachments/assets/517e48ce-1b6e-445a-bc2a-0e022a53b925)



### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

### - 


```

```


### - 실행 결과


```

```

